// Copyright (c) EZBLOCK INC. & AUTHORS
// SPDX-License-Identifier: BSD-3-Clause

package qrcode

import (
	api "cylonix/sase/api/v2"
	"cylonix/sase/api/v2/models"
	"cylonix/sase/daemon/common"
	"cylonix/sase/daemon/db"
	"cylonix/sase/daemon/db/types"
	"cylonix/sase/pkg/optional"
	"cylonix/sase/pkg/vpn"
	"errors"
	"time"

	"github.com/cylonix/utils"
	ulog "github.com/cylonix/utils/log"

	"github.com/sirupsen/logrus"
)

/*
 * QR code scanning flow:
 * 1. To request for authorization grant:
 *    - Requester requests a new QR code to be generated for auth-request.
 *	  - Requester receives the qr code token.
 *    - Requester shows the qr code.
 *    - Requester polls repeatedly to check if it is approved.
 *    + Approver scans the qr code.
 *    + Approver approves, ignores or rejects the auth-request.
 *
 * 2. To grant authorization:
 *    + Approver requests a new short lived QR code for auth-grant.
 *    + Approver receives the qr code token.
 *    + Approver shows the qr code.
 *    + Approver polls repeatedly to check if it has been scanned.
 *    + Approver approves, ignores or rejects the auth-request.
 *    - Requester scans the qr code to request for auth-grant.
 *    - Requester poll repeatedly to check if the auth has been granted.
 *
 * For security:
 *    - Auth token information is saved into the qr code token state only
 *      after auth-grant is confirmed.
 *    - Once grant is confirmed, the qr code token has short expiration time.
 *    - An auth-grant token can only be scanned once by a requestor.
 *    - An auth-request token can be scanned multiple times.
 *    - A confirmed token is deleted on next get request from a non-granter.
 *    - A unique/random requester ID is generated by the requester to protect
 *      replay attacks.
 *      TODO: encrypt with a requester public key instead.
 */
type handlerImpl struct {
	logger *logrus.Entry
}

func newHandlerImpl(logger *logrus.Entry) *handlerImpl {
	return &handlerImpl{
		logger: logger,
	}
}

func canGrantAuth(token *utils.UserTokenData) bool {
	return token != nil && (token.IsAdminUser || token.FromApprovedDevice)
}

func (h *handlerImpl) CreateQrCode(auth interface{}, requestObject api.CreateQrCodeRequestObject) (*utils.QRCodeToken, error) {
	r := requestObject.Body
	if r == nil || r.ID == "" {
		err := errors.New("missing input or id")
		return nil, common.NewBadParamsErr(err)
	}
	params := requestObject.Params
	data := &utils.QRCodeAuthTokenData{
		State:          string(models.QrCodeTokenDataStateCreated),
		TokenType:      string(params.QrCodeType),
		CreatedAt:      time.Now().Unix(),
		WantVpnAuthKey: optional.Bool(r.WantVpnAuthKey),
	}

	token, _, _, logger := common.ParseToken(auth, "crete-qr-code", "Create QR Code", h.logger)
	switch data.TokenType {
	case utils.QRCodeTokenTypeAuthGrant:
		if !canGrantAuth(token) {
			return nil, common.ErrModelUnauthorized
		}
		data.GranterID = r.ID
		data.GranterHostname = optional.String(r.Hostname)
		data.GranterUserAgent = optional.String(r.UserAgent)
	case utils.QRCodeTokenTypeAuthRequest:
		data.RequesterID = r.ID
		data.RequesterHostname = optional.String(r.Hostname)
		data.RequesterUserAgent = optional.String(r.UserAgent)
	default:
		err := errors.New("invalid token type")
		return nil, common.NewBadParamsErr(err)
	}

	// Don't fill in the user token information until it is approved.
	qrToken := utils.NewQRCodeToken()
	err := qrToken.Create(data)
	if err != nil {
		logger.WithError(err).Errorln("Failed to set qr code token data.")
		return nil, common.ErrInternalErr
	}
	return qrToken, nil
}

// UpdateQrCodeToken updates the qr code token state.
// Confirm state: only allowed from admin or user from approved device.
// Scanned state: only allowed once from a requestor.
func (h *handlerImpl) UpdateQrCodeToken(auth interface{}, requestObject api.UpdateQrCodeTokenRequestObject) error {
	token, _, _, logger := common.ParseToken(auth, "update-qr-code-token-state", "Update QR Code auth grant state", h.logger)
	params := requestObject.Body
	qrToken := &utils.QRCodeToken{Token: requestObject.QrCodeToken}
	qrData := &utils.QRCodeAuthTokenData{}
	if err := qrToken.Get(qrData); err != nil {
		logger.WithError(err).Errorln("Failed to get qr code token data.")
		return common.ErrInternalErr
	}
	if params == nil || params.State == "" {
		logger.Debugln("Missing params")
		err := errors.New("missing input or state")
		return common.NewBadParamsErr(err)
	}
	r := params.Requester
	if r == nil || r.ID == "" {
		logger.Debugln("Missing requester ID")
		err := errors.New("missing requester or requester id")
		return common.NewBadParamsErr(err)
	}
	newState := params.State
	if qrData.TokenType == utils.QRCodeTokenTypeAuthRequest {
		if qrData.RequesterID == r.ID {
			if newState != models.QrCodeTokenDataStateScanned {
				logger.Debugln("Unauthorized to update an auth-request token")
				return common.ErrModelUnauthorized
			}
		} else {
			if !canGrantAuth(token) {
				logger.Debugln("Unauthorized to update an auth-request token")
				return common.ErrModelUnauthorized
			}
			if qrData.GranterID == "" {
				qrData.GranterID = r.ID
				qrData.GranterUserAgent = optional.String(r.UserAgent)
				qrData.GranterHostname = optional.String(r.Hostname)
			}
		}
	} else if qrData.TokenType == utils.QRCodeTokenTypeAuthGrant {
		if qrData.RequesterID == "" {
			qrData.RequesterID = r.ID
			qrData.RequesterUserAgent = optional.String(r.UserAgent)
			qrData.RequesterHostname = optional.String(r.Hostname)
		}
	}
	state := qrData.State
	logger = logger.WithField("qr-code", requestObject.QrCodeToken).WithField("state", newState)
	switch newState {
	case models.QrCodeTokenDataStateScanned:
		if state == string(newState) {
			logger.Debugln("Already scanned.")
			if qrData.RequesterID == r.ID {
				return nil
			}
			return common.ErrModelUnauthorized
		}
	case models.QrCodeTokenDataStateRejected:
		if !canGrantAuth(token) || r.ID != qrData.GranterID {
			logger.Debugln("Unauthorized to reject token")
			return common.ErrModelUnauthorized
		}
	case models.QrCodeTokenDataStateConfirmed:
		if !canGrantAuth(token) || r.ID != qrData.GranterID {
			logger.Debugln("Unauthorized to confirm token")
			return common.ErrModelUnauthorized
		}
		newToken, err := token.Clone()
		if err != nil {
			return common.ErrInternalErr
		}
		qrData.GranterUserToken = newToken.Token
	}

	qrData.State = string(newState)
	if err := qrToken.Update(qrData); err != nil {
		logger.WithError(err).Errorln("Failed to update qr code token data.")
		return common.ErrInternalErr
	}
	return nil
}

// CheckQrCodeState checks the current QR code state.
//
// Approver checks if the code has been scanned so as to show the user the
// approval request and confirm, if approver created the qr code to grant
// authorization to someone else.
//
// Requester checks the state regardless if the token is created by the
// requester.
func (h *handlerImpl) CheckQrCodeState(auth interface{}, requestObject api.CheckQrCodeStateRequestObject) (*models.QrCodeTokenData, error) {
	authToken, _, _, logger := common.ParseToken(auth, "check-qr-code-state", "Check QR code state", h.logger)
	logger = logger.WithField("qr-code", requestObject.QrCodeToken)
	params := requestObject.Params
	qrToken := &utils.QRCodeToken{
		Token: requestObject.QrCodeToken,
	}
	data := &utils.QRCodeAuthTokenData{}
	if err := qrToken.Get(data); err != nil {
		if errors.Is(err, utils.ErrTokenNotExists) {
			return nil, common.NewBadParamsErr(err)
		}
		if errors.Is(err, utils.ErrTokenExpired) {
			state := models.QrCodeTokenDataStateExpired
			return &models.QrCodeTokenData{State: state}, nil
		}
		logger.WithError(err).Errorln("Failed to get qr code token data.")
		return nil, common.ErrInternalErr
	}
	state := data.State
	id := optional.String(params.RequesterID)

	// Only allow polling from the known requester or an granter.
	// For first time polling, an empty ID will match.
	if (!canGrantAuth(authToken) && data.RequesterID != "" && data.RequesterID != id) ||
		(canGrantAuth(authToken) && data.GranterID != "" && data.GranterID != id) {
		logger.WithField("id", id).Debugln("ID does not match.")
		return nil, common.ErrModelUnauthorized
	}

	// Polling from a granter.
	if canGrantAuth(authToken) {
		return &models.QrCodeTokenData{
			State: models.QrCodeTokenDataState(state),
			Requester: &models.QrCodeRequester{
				Hostname:  &data.RequesterHostname,
				Timestamp: &data.CreatedAt,
				UserAgent: &data.RequesterUserAgent,
			},
		}, nil
	}

	// Polling from a requester.
	if state != string(models.QrCodeTokenDataStateConfirmed) {
		return &models.QrCodeTokenData{
			State: models.QrCodeTokenDataState(state),
			Requester: &models.QrCodeRequester{
				Hostname:  &data.GranterHostname,
				Timestamp: &data.CreatedAt,
				UserAgent: &data.GranterUserAgent,
			},
		}, nil
	}

	// Qr code auth has been granted. Send requester auth information.
	token, granter, err := utils.GetUserOrAdminTokenWithKey(data.GranterUserToken)
	if err != nil {
		logger.WithError(err).Errorln("Failed to get token data.")
		if errors.Is(err, utils.ErrTokenExpired) || errors.Is(err, utils.ErrTokenNotExists) {
			qrToken.Delete()
			state := models.QrCodeTokenDataStateExpired
			return &models.QrCodeTokenData{State: state}, nil
		}
		return nil, common.ErrInternalErr
	}
	namespace := granter.Namespace
	logger = logger.WithField(ulog.Namespace, namespace)

	user, err := db.GetUserFast(namespace, types.UUIDToID(granter.UserID), false)
	if err != nil {
		logger.WithError(err).Errorln("Failed to get approver info from db.")
		if errors.Is(err, db.ErrUserNotExists) {
			qrToken.Delete()
			token.Delete()
			return nil, common.ErrModelUnauthorized
		}
		return nil, common.ErrInternalErr
	}

	tenant, err := db.GetTenantConfigByNamespace(namespace)
	if err != nil {
		logger.WithError(err).Errorln("company not yet registered")
		return nil, common.ErrModelCompanyNotExists
	}
	companyName := tenant.Name

	var vpnAuthKey *string
	if data.WantVpnAuthKey {
		vpnAuthKey, err = vpn.CreatePreAuthKey(
			&vpn.UserInfo{
				Namespace: namespace,
				UserID:    user.ID,
				LoginName: user.UserBaseInfo.LoginName,
				Network:   optional.V(user.NetworkDomain, ""),
			},
			token.Key(),
			nil /* no assigned ip */,
		)
		if err != nil {
			logger.WithError(err).Errorln("Failed to create vpn pre auth key.")
			return nil, common.ErrInternalErr
		}
	}

	// All done. Delete token before returning.
	qrToken.Delete()
	return &models.QrCodeTokenData{
		Requester: &models.QrCodeRequester{
			ID: data.RequesterID, // So that requester can check.
		},
		APIKey: &models.APIKey{
			Key: data.GranterUserToken,
			TTL: optional.IntP(1800),
		},
		VpnAuthKey: vpnAuthKey,
		Tenant: &models.Tenant{
			Name:      companyName,
			Namespace: &user.Namespace,
			TenantID:  tenant.ID.UUIDP(),
		},
		User:  user.ToModel(),
		State: models.QrCodeTokenDataState(state),
	}, nil
}
