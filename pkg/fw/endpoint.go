// Copyright 2016-2017 Authors of Cilium
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package client

import (
	"context"
	"cylonix/sase/pkg/optional"
	"errors"
	"fmt"
	"net/url"
	"strings"

	api "github.com/cylonix/fw"
)

const (
	// LabelSourceUnspec is a label with unspecified source
	LabelSourceUnspec = "unspec"

	// LabelSourceAny is a label that matches any source
	LabelSourceAny = "any"

	// LabelSourceAnyKeyPrefix is prefix of a "any" label
	LabelSourceAnyKeyPrefix = LabelSourceAny + "."

	// LabelSourceK8s is a label imported from Kubernetes
	LabelSourceK8s = "k8s"

	// LabelSourceMesos is a label imported from Mesos
	LabelSourceMesos = "mesos"

	// LabelSourceK8sKeyPrefix is prefix of a Kubernetes label
	LabelSourceK8sKeyPrefix = LabelSourceK8s + "."

	// LabelSourceContainer is a label imported from the container runtime
	LabelSourceContainer = "container"

	// LabelSourceReserved is the label source for reserved types.
	LabelSourceReserved = "reserved"

	// LabelSourceCIDR is the label source for generated CIDRs.
	LabelSourceCIDR = "cidr"

	// LabelSourceReservedKeyPrefix is the prefix of a reserved label
	LabelSourceReservedKeyPrefix = LabelSourceReserved + "."

	// LabelKeyFixedIdentity is the label that can be used to define a fixed
	// identity.
	LabelKeyFixedIdentity = "io.cilium.fixed-identity"

	// LabelSourceCiliumGenerated is for labels auto-generated by cilium without
	// user input
	LabelSourceCiliumGenerated = "cilium-generated"
)

var (
	ErrEndpointNotExist = errors.New("endpoint does not exist")
)

// EndpointList returns a list of all endpoints
func (c *Client) EndpointList() ([]api.Endpoint, error) {

	list, _, err := c.EndpointAPI.EndpointGet(context.TODO()).Execute()
	if err != nil {
		return nil, Hint(err)
	}
	return list, nil
}

// EndpointGet returns endpoint by ID
func (c *Client) EndpointGet(id string) (*api.Endpoint, error) {
	ep, _, err := c.EndpointAPI.EndpointIDGet(context.TODO(), id).Execute()
	if err != nil {
		/* Since plugins rely on checking the error type, we don't wrap this
		 * with Hint(...)
		 */
		return nil, err
	}
	return ep, nil
}

// NewCiliumID returns a new endpoint identifier of type CiliumLocalIdPrefix
func newCiliumID(id int64) string {
	return fmt.Sprintf("%s:%d", "cilium-local", id)
}

func newIpQueryString(namespace, ip string) string {
	if namespace != "" {
		return namespace + "-ipv4:" + ip
	}
	return "ipv4:" + ip
}

// EndpointGetWithIP returns the endpoint matching the endpoint IP.
func (c *Client) EndpointGetWithIP(namespace, ip string) (*api.Endpoint, error) {
	// Todo: add such an api in sase-tai instead.
	ep, err := c.EndpointGet(url.QueryEscape(newIpQueryString(namespace, ip)))
	if err != nil {
		if strings.Contains(err.Error(), "404") {
			return nil, ErrEndpointNotExist
		}
		return nil, Hint(err)
	}
	return ep, nil
}

// EndpointCreate creates a new endpoint
func (c *Client) EndpointCreate(ep *api.EndpointChangeRequest) error {
	id := newCiliumID(int64(optional.V(ep.ID, 0)))
	_, err := c.EndpointAPI.EndpointIDPut(context.TODO(), id).Endpoint(*ep).Execute()
	return Hint(err)
}

// EndpointPatch modifies the endpoint
func (c *Client) EndpointPatch(id string, ep *api.EndpointChangeRequest) error {
	if id == "" {
		id = newCiliumID(int64(optional.V(ep.ID, 0)))
	}
	_, err := c.EndpointAPI.EndpointIDPatch(context.TODO(), id).Endpoint(*ep).Execute()
	return Hint(err)
}

// EndpointDelete deletes endpoint
func (c *Client) EndpointDelete(id string) error {
	_, err := c.EndpointAPI.EndpointIDDelete(context.TODO(), id).Execute()
	return Hint(err)
}

// EndpointLogGet returns endpoint log
func (c *Client) EndpointLogGet(id string) ([]api.EndpointStatusChange, error) {
	ret, _, err := c.EndpointAPI.EndpointIDLogGet(context.TODO(), id).Execute()
	if err != nil {
		return nil, Hint(err)
	}
	return ret, nil
}

// EndpointHealthGet returns endpoint healthz
func (c *Client) EndpointHealthGet(id string) (*api.EndpointHealth, error) {
	ret, _, err := c.EndpointAPI.EndpointIDHealthzGet(context.TODO(), id).Execute()
	if err != nil {
		return nil, Hint(err)
	}
	return ret, nil
}

// EndpointConfigGet returns endpoint configuration
func (c *Client) EndpointConfigGet(id string) (*api.EndpointConfigurationStatus, error) {
	ret, _, err := c.EndpointAPI.EndpointIDConfigGet(context.TODO(), id).Execute()
	if err != nil {
		return nil, Hint(err)
	}
	return ret, nil
}

// EndpointConfigPatch modifies endpoint configuration
func (c *Client) EndpointConfigPatch(id string, cfg *api.EndpointConfigurationSpec) error {
	req := c.EndpointAPI.EndpointIDConfigPatch(context.TODO(), id)
	if cfg != nil {
		req = req.EndpointConfiguration(*cfg)
	}
	_, err := req.Execute()
	return Hint(err)
}

// EndpointLabelsGet returns endpoint label configuration
func (c *Client) EndpointLabelsGet(id string) (*api.LabelConfiguration, error) {
	ret, _, err := c.EndpointAPI.EndpointIDLabelsGet(context.TODO(), id).Execute()
	if err != nil {
		return nil, Hint(err)
	}
	return ret, nil
}

// Label is the cilium's representation of a container label.
type Label struct {
	Key   string `json:"key"`
	Value string `json:"value,omitempty"`
	// Source can be one of the values present in const.go (e.g.: LabelSourceContainer)
	Source string `json:"source"`
}

// Labels is a map of labels where the map's key is the same as the label's key.
type Labels map[string]Label

// NewLabelsFromModel creates labels from string array.
func NewLabelsFromModel(base []string) Labels {
	lbls := make(Labels, len(base))
	for _, v := range base {
		if lbl := ParseLabel(v); lbl.Key != "" {
			lbls[lbl.Key] = lbl
		}
	}

	return lbls
}

// parseSource returns the parsed source of the given str. It also returns the next piece
// of text that is after the source.
// Example:
//
//	src, next := parseSource("foo:bar==value")
//
// Println(src) // foo
// Println(next) // bar==value
// For Cilium format 'delim' must be passed in as ':'
// For k8s format 'delim' must be passed in as '.'
func parseSource(str string, delim byte) (src, next string) {
	if str == "" {
		return "", ""
	}
	if str[0] == '$' {
		return LabelSourceReserved, str[1:]
	}
	i := strings.IndexByte(str, delim)
	if i < 0 {
		if delim != '.' && strings.HasPrefix(str, LabelSourceReservedKeyPrefix) {
			return LabelSourceReserved, strings.TrimPrefix(str, LabelSourceReservedKeyPrefix)
		}
		return "", str
	}
	return str[:i], str[i+1:]
}

// ParseLabel returns the label representation of the given string. The str should be
// in the form of Source:Key=Value or Source:Key if Value is empty. It also parses short
// forms, for example: $host will be Label{Key: "host", Source: "reserved", Value: ""}.
func ParseLabel(str string) Label {
	return parseLabel(str, ':')
}

// parseLabel returns the label representation of the given string by value.
// For Cilium format 'delim' must be passed in as ':'
// For k8s format 'delim' must be passed in as '.'
func parseLabel(str string, delim byte) (lbl Label) {
	src, next := parseSource(str, delim)
	if src != "" {
		lbl.Source = src
	} else {
		lbl.Source = LabelSourceUnspec
	}

	i := strings.IndexByte(next, '=')
	if i < 0 {
		lbl.Key = next
	} else {
		if i == 0 && src == LabelSourceReserved {
			lbl.Key = next[i+1:]
		} else {
			lbl.Key = next[:i]
			lbl.Value = next[i+1:]
		}
	}
	return lbl
}

// EndpointLabelsPut modifies endpoint label configuration
// add: List of labels to add and enable. If the label is an orchestration
// system label which has been disabled before, it will be removed from
// the disabled list and read to the orchestration list. Otherwise
// it will be added to the custom label list.
//
// delete: List of labels to delete. If the label is an orchestration system
// label, then it will be deleted from the orchestration list and
// added to the disabled list. Otherwise it will be removed from the
// custom list.
func (c *Client) EndpointLabelsPatch(id string, toAdd, toDelete []string) error {
	currentCfg, err := c.EndpointLabelsGet(id)
	if err != nil {
		return err
	}

	userLbl := NewLabelsFromModel(currentCfg.Status.Realized.User)
	for _, lbl := range toAdd {
		lblParsed := ParseLabel(lbl)
		if _, found := userLbl[lblParsed.Key]; !found {
			userLbl[lblParsed.Key] = lblParsed
		}
	}
	for _, lbl := range toDelete {
		lblParsed := ParseLabel(lbl)
		delete(userLbl, lblParsed.Key)
	}
	currentCfg.Spec.User = userLbl.GetModel()

	_, err = c.EndpointAPI.EndpointIDLabelsPatch(context.TODO(), id).Configuration(*currentCfg.Spec).Execute()
	return Hint(err)
}

// GetModel returns model with all the values of the labels.
func (l Labels) GetModel() []string {
	res := make([]string, 0, len(l))
	for _, v := range l {
		res = append(res, v.String())
	}
	return res
}

// String returns the string representation of Label in the for of Source:Key=Value or
// Source:Key if Value is empty.
func (l *Label) String() string {
	if len(l.Value) != 0 {
		return fmt.Sprintf("%s:%s=%s", l.Source, l.Key, l.Value)
	}
	return fmt.Sprintf("%s:%s", l.Source, l.Key)
}

func (c *Client) DeleteEndpointByLabel(labels []string) error {
	apList, _, err := c.EndpointAPI.EndpointGet(context.TODO()).Labels(labels).Execute()
	if err != nil {
		log.Errorln("Failed to list endpoint by device ID", err)
		return Hint(err)
	}

	for _, endpoint := range apList {
		log.Infoln("Try to delete cilium endpoint by ID ", endpoint.ID)
		err := c.EndpointDelete(fmt.Sprintf("%d", endpoint.ID))
		if err != nil {
			log.Infoln("Failed to delete cilium endpoint ", err)
		}
	}

	return nil
}
